from pydantic import BaseModel, Field, HttpUrl
from typing import List, Optional, Literal, Union
from datetime import datetime
from uuid import UUID, uuid4

# --- New, More Advanced Template Models ---

class StaticSegmentSource(BaseModel):
    """Defines a segment that uses a pre-uploaded audio file."""
    source_type: Literal["static"] = "static"
    filename: str = Field(..., description="The filename of the uploaded audio in temp_uploads.")

class AIGeneratedSegmentSource(BaseModel):
    """Defines a segment that will be generated by AI on the fly."""
    source_type: Literal["ai_generated"] = "ai_generated"
    prompt: str = Field(..., description="The text prompt for the AI to generate the script.")
    voice_id: str = Field("19B4gjtpL5m876wS3Dfg", description="The ElevenLabs voice ID to use for generation.")

class TemplateSegment(BaseModel):
    """
    Represents a single, versatile segment within a podcast template (e.g., an intro, outro, etc.).
    """
    id: UUID = Field(default_factory=uuid4)
    segment_type: Literal["intro", "content", "outro", "commercial", "sound_effect", "transition"]
    
    # This field allows us to use either a static file or an AI-generated source
    source: Union[StaticSegmentSource, AIGeneratedSegmentSource] = Field(..., discriminator='source_type')

class BackgroundMusicRule(BaseModel):
    """
    Defines a rule for applying background music to specific parts of the podcast.
    """
    id: UUID = Field(default_factory=uuid4)
    music_filename: str = Field(..., description="The filename of the background music track.")
    
    # Defines which segment types this music should be applied to (e.g., ['intro', 'outro'])
    apply_to_segments: List[Literal["intro", "content", "outro"]]
    
    # Precise timing controls
    start_offset_s: float = Field(0.0, description="Music starts this many seconds after the section begins.")
    end_offset_s: float = Field(0.0, description="Music ends this many seconds before the section finishes.")
    fade_in_s: float = Field(2.0, description="Fade-in duration in seconds.")
    fade_out_s: float = Field(3.0, description="Fade-out duration in seconds.")
    volume_db: int = Field(-15, description="Volume adjustment in dB (e.g., -15 is quieter).")

class PodcastTemplate(BaseModel):
    """
    Defines the reusable structure for a podcast series with advanced, rule-based assembly.
    """
    id: UUID = Field(default_factory=uuid4)
    user_id: UUID = Field(..., description="The user who owns this template")
    name: str = Field(..., description="User-defined name for the template (e.g., 'Weekly Interview')")
    
    # A list of all segments in the order they should appear.
    # The 'content' segment acts as a placeholder for the main episode recording.
    segments: List[TemplateSegment]
    
    # A list of specific rules for background music.
    background_music_rules: List[BackgroundMusicRule] = Field(default_factory=list)


# --- Existing Models (Slightly modified for context) ---

class AudioSegment(BaseModel):
    """Represents a single, processed piece of audio ready for stitching."""
    id: UUID = Field(default_factory=uuid4)
    # This can be the original filename or a generated name for AI segments
    source_name: str
    storage_path: str = Field(..., description="Path to the file in cloud storage or a local temp dir.")
    duration_seconds: float = Field(0.0)
    segment_type: Literal["intro", "content", "outro", "commercial", "sound_effect", "transition"]

class Episode(BaseModel):
    """Represents a single podcast episode being processed or published."""
    id: UUID = Field(default_factory=uuid4)
    user_id: UUID = Field(..., description="The user who owns this episode")
    template_id: UUID = Field(..., description="The template used to create this episode")
    title: Optional[str] = Field(None, description="Episode title (can be AI-generated)")
    show_notes: Optional[str] = Field(None, description="Episode show notes (can be AI-generated)")
    tags: List[str] = Field(default_factory=list, description="Keywords/tags for the episode")
    status: Literal["pending", "processing", "processed", "published", "error"] = "pending"
    created_at: datetime = Field(default_factory=datetime.utcnow)
    publish_date: Optional[datetime] = None
    final_audio_path: Optional[str] = Field(None, description="Path to the final mixed audio file")
    transcript_path: Optional[str] = Field(None, description="Path to the generated transcript file")
    cover_image_url: Optional[HttpUrl] = Field(None, description="URL for the episode's cover image")
